"use strict";{const t=Math.pow(2,26),s=2147483647;function e(s,e){return s*t+e}function i(s){return[Math.floor(s/t),s%t]}function l(t,s){const e=[];for(let i=0;i<t;++i)e.push(new Int32Array(s));return e}const h=new Map;function n(t){let s=h.get(t);return s||(s=new r,h.set(t,s)),s}self.JobHandlers["PFCellData"]=function(t){const s=t["mapKey"],e=t["hcells"],i=t["vcells"],l=t["cellData"];n(s).Init(e,i,l)},self.JobHandlers["PFUpdateRegion"]=function(t){const s=t["mapKey"],e=t["cx1"],i=t["cy1"],l=t["lenx"],h=t["leny"],o=t["cellData"];n(s).UpdateRegion(e,i,l,h,o)},self.JobHandlers["PFResetAllCellData"]=function(t){for(const t of h.values())t.Clear()},self.JobHandlers["PFFindPath"]=function(t){const s=t["mapKey"],e=t["cellX"],i=t["cellY"],l=t["destCellX"],h=t["destCellY"],o=t["moveCost"],a=t["diagonalsEnabled"],r=t["directMovementMode"],_=n(s),d=t["pathGroup"];_.IsInPathGroup()?d?_.GetPathGroupId()!==d["id"]&&(_.EndGroup(),_.StartGroup(d["id"],d["cost"],d["cellSpread"])):_.EndGroup():d&&_.StartGroup(d["id"],d["cost"],d["cellSpread"]),_.SetMoveCost(o),_.SetDiagonalsEnabled(a);return{result:_.FindPath(e,i,l,h,r)}};let o=0;class a{constructor(t,s){this._parent=null,this._x=t||0,this._y=s||0,this._f=0,this._g=0,this._h=0,this._seq=o++}SetXY(t,s){this._x=t,this._y=s}static Sort(t,s){const e=t._f,i=s._f;return e!==i?e-i:t._seq-s._seq}}class r{constructor(){this._adjacentCost=10,this._diagonalCost=14,this._hcells=0,this._vcells=0,this._cells=null,this._openList=new self.RedBlackSet(a.Sort),this._openMap=new Map,this._closedSet=new Set,this._currentNode=null,this._targetX=0,this._targetY=0,this._diagonalsEnabled=!0,this._isInPathGroup=!1,this._pathGroupId=-1,this._pathGroupCost=0,this._pathGroupCellSpread=0,this._groupCostCells=null}Init(t,s,e){this._hcells===t&&this._vcells===s||this.EndGroup(),this._hcells=t,this._vcells=s,this._cells=e}UpdateRegion(t,s,e,i,l){const h=this._cells;if(h)for(let i=0;i<e;++i)h[t+i].set(l[i],s)}Clear(){this.EndGroup(),this._cells=null}_ClearIntermediateData(){this._openList.Clear(),this._openList=new self.RedBlackSet(a.Sort),this._openMap.clear(),this._closedSet.clear(),this._currentNode=null,o=0}UpdateRegion(t,s,e,i,l){for(let h=0;h<e;++h)for(let e=0;e<i;++e)this._cells[t+h][s+e]=l[h][e]}SetMoveCost(t){this._adjacentCost=Math.floor(t),this._diagonalCost=Math.round(this._adjacentCost*Math.SQRT2)}SetDiagonalsEnabled(t){this._diagonalsEnabled=!!t}StartGroup(t,s,e){this._isInPathGroup||(this._isInPathGroup=!0,this._pathGroupId=t,this._pathGroupCost=s,this._pathGroupCellSpread=e,this._groupCostCells=l(this._hcells,this._vcells))}EndGroup(){this._isInPathGroup&&(this._isInPathGroup=!1,this._pathGroupId=-1,this._groupCostCells=null)}IsInPathGroup(){return this._isInPathGroup}GetPathGroupId(){return this._pathGroupId}At(t,e){if(t<0||e<0||t>=this._hcells||e>=this._vcells)return s;let i=this._cells[t][e];return null!==this._groupCostCells&&(i=Math.min(i+this._groupCostCells[t][e],s)),i}IsBoxAllClear(t,s,e,i){const l=Math.min(t,e),h=Math.max(t,e),n=Math.min(s,i),o=Math.max(s,i);for(let t=l;t<=h;++t){const s=this._cells[t];for(let t=n;t<=o;++t)if(0!==s[t])return!1}return!0}FindPath(t,s,e,i,l){if(!this._cells)return null;t=Math.floor(t),s=Math.floor(s),e=Math.floor(e),i=Math.floor(i),this._targetX=e,this._targetY=i;const h=Math.min(t,e),n=Math.max(t,e),o=Math.min(s,i),a=Math.max(s,i);return h<0||o<0||n>=this._hcells||a>=this._vcells?null:0!==l&&this.IsBoxAllClear(t,s,e,i)?[{x:e,y:i}]:this._AStarFindPath(t,s,l)}_AStarFindPath(t,i,l){const h=this._adjacentCost,n=this._diagonalCost,o=this._diagonalsEnabled,r=this._openList,_=this._openMap,d=this._closedSet,c=new a(t,i);for(r.Add(c),_.set(e(t,i),c);!r.IsEmpty();){const t=r.Shift(),i=e(t._x,t._y);if(_.delete(i),d.add(i),t._x===this._targetX&&t._y===this._targetY)return this._ClearIntermediateData(),this._GetResultPath(t,l);this._currentNode=t;const a=t._x,c=t._y,p=this.At(a-1,c)===s,u=this.At(a,c-1)===s,f=this.At(a+1,c)===s,C=this.At(a,c+1)===s;p||this._AddCellToOpenList(a-1,c,h),!o||p||u||this.At(a-1,c-1)===s||this._AddCellToOpenList(a-1,c-1,n),u||this._AddCellToOpenList(a,c-1,h),!o||u||f||this.At(a+1,c-1)===s||this._AddCellToOpenList(a+1,c-1,n),f||this._AddCellToOpenList(a+1,c,h),!o||f||C||this.At(a+1,c+1)===s||this._AddCellToOpenList(a+1,c+1,n),C||this._AddCellToOpenList(a,c+1,h),!o||C||p||this.At(a-1,c+1)===s||this._AddCellToOpenList(a-1,c+1,n)}return this._ClearIntermediateData(),null}_AddCellToOpenList(t,s,i){const l=e(t,s);if(this._closedSet.has(l))return;const h=this.At(t,s),n=this._openMap.get(l);n?this._currentNode._g+i+h<n._g&&this._UpdateNodeInOpenList(n,i,h):this._AddNewNodeToOpenList(t,s,i,h)}_UpdateNodeInOpenList(t,s,e){const i=this._openList,l=this._currentNode;i.Remove(t),t._parent=l,t._g=l._g+s+e,t._h=this._EstimateH(t._x,t._y),t._f=t._g+t._h,i.Add(t)}_AddNewNodeToOpenList(t,s,i,l){const h=new a(t,s),n=this._EstimateH(t,s),o=this._currentNode._g+i+l;h._h=n,h._g=o,h._f=n+o,h._parent=this._currentNode,this._openMap.set(e(t,s),h),this._openList.Add(h)}_EstimateH(t,s){const e=Math.abs(t-this._targetX),i=Math.abs(s-this._targetY),l=this._adjacentCost*(e+i);return this._diagonalsEnabled?l+(this._diagonalCost-2*this._adjacentCost)*Math.min(e,i):l}_GetResultPath(t,s){let e=[],i=t;for(;i;)e.push({x:i._x,y:i._y}),i=i._parent;return e.reverse(),this._isInPathGroup&&this._AddPathGroupCost(e),e=this._FilterRedundantNodes(e),2===s&&(e=this._FilterNodesForDirectMovement(e),e=this._FilterRedundantNodes(e)),e.length>1&&e.shift(),e}_AddPathGroupCost(t){const s=this._pathGroupCost,l=this._pathGroupCellSpread,h=Math.floor(l/2),n=this._hcells,o=this._vcells,a=new Set;for(const s of t){const t=s.x,i=s.y,r=Math.max(t-h,0),_=Math.max(i-h,0),d=Math.min(r+l,n),c=Math.min(_+l,o);for(let t=r;t<d;++t)for(let s=_;s<c;++s)a.add(e(t,s))}for(const t of a){const[e,l]=i(t);this._groupCostCells[e][l]+=s}}_FilterRedundantNodes(t){if(0===t.length)return[];let s=t[0];if(1===t.length)return[s];const e=[s];let i=t[1],l=i.x-s.x,h=i.y-s.y;const n=1e-7;for(let o=1,a=t.length;o<a;++o)if(s=t[o],o===a-1)e.push(s);else{i=t[o+1];const a=i.x-s.x,r=i.y-s.y,_=Math.abs(a)<n&&Math.abs(l)<n&&Math.sign(r)===Math.sign(h),d=Math.abs(r)<n&&Math.abs(h)<n&&Math.sign(a)===Math.sign(l);!_&&!d&&Math.abs(a/l-r/h)>.001&&(e.push(s),l=a,h=r)}return e}_FilterNodesForDirectMovement(t){if(0===t.length)return[];if(t.length<=2)return t.slice(0);const s=[];let e=0,i=t.length;for(;e<i;){const l=t[e];if(s.push(l),e>=i-2)++e;else{let s=e+1;for(;s<i&&(e=s,++s,!(s>=i));){const e=t[s];if(!this.IsBoxAllClear(l.x,l.y,e.x,e.y))break}}}return s}}}